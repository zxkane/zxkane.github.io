<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring Cloud Function on The road</title><link>https://kane.mx/tags/spring-cloud-function/</link><description>Recent content in Spring Cloud Function on The road</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2021, Kane Zhu; all rights reserved.</copyright><lastBuildDate>Fri, 28 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://kane.mx/tags/spring-cloud-function/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Cloud Function -- 跨Serverless平台的函数计算框架</title><link>https://kane.mx/posts/effective-cloud-computing/spring-cloud-function-for-aws/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://kane.mx/posts/effective-cloud-computing/spring-cloud-function-for-aws/</guid><description>
&lt;p>&lt;a href="https://kane.mx/posts/2019/serverless-framework/">基于serverless框架的钉钉回调函数&lt;/a>中介绍了serverless framework，一款支持跨云厂商/Serverless平台的部署工具。但是函数代码还是需要针对不同的serverless平台作对应的适配。而&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a>就是针对这种情况专门开发的跨serverless平台的框架，实现一套代码通过不同的打包实现跨serverless平台。Spring Clound Function目前支持AWS Lambda, Microsoft Azure Function以及Apache OpenWhisk。&lt;/p>
&lt;p>这里我们继续使用&lt;a href="https://kane.mx/posts/effective-cloud-computing/serverless-dingtalk-callback/">无函数版本的钉钉回掉函数&lt;/a>来演示&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a> for AWS的使用。&lt;/p>
&lt;p>首先将&lt;code>spring cloud function for aws adapter&lt;/code>添加到项目依赖，&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln">1&lt;/span>&lt;span class="n">implementation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;org.springframework.cloud:spring-cloud-function-adapter-aws:&lt;/span>&lt;span class="si">${springCloudFunctionVersion}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>其次创建函数&lt;code>Handler&lt;/code>，实现Spring Cloud Function跨函数计算实现抽象的&lt;code>SpringBootRequestHandler&lt;/code>类，或者是继承自它的trigger类，例如&lt;code>SpringBootApiGatewayRequestHandler&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="nn">org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Handler&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">SpringBootApiGatewayRequestHandler&lt;/span>&lt;span class="p">()&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>接下来创建Spring Boot应用程序，并将serverless实现函数注册为&lt;code>Spring Bean&lt;/code>，函数的实现部分就是serverless函数具体做的业务逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln"> 1&lt;/span>&lt;span class="nd">@SpringBootApplication&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">DingtalkCallbackApplication&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nd">@Bean&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">open&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">dingtalkCallback&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Function&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">EncryptedEvent&lt;/span>&lt;span class="p">&amp;gt;,&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">callback&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Callback&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Function&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">callback&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">handleRequest&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">SpringApplication&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">DingtalkCallbackApplication&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>最后将函数打包为fat jar（如果将依赖打包为lambda layer，可不用打包为fat jar）作为lambda的代码。&lt;/p>
&lt;p>函数的部署同其他的lambda函数没有任何区别，这个示例中沿用了之前的SAM/CloudFormation配置或者&lt;a href="https://serverless.com/">serverless framework&lt;/a>部署配置。&lt;/p>
&lt;p>完整的可运行、部署代码请访问&lt;a href="https://github.com/zxkane/dingtalk-callback-on-aws/tree/spring-cloud-function">这个分支&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>总体来说，&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a>的实现原理并不复杂，定义统一的函数实现入口，通过不同serverless平台的adapter对接不同平台的API接口，做到编写一次函数实现，通过打包不同的adapter做到跨serverless平台运行。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>但个人认为现实中这样的场景并不多。并且serverless函数触发方式很多，例如AWS上的APIGateway、Kinesis、CloudWatch、IoT等服务，与这些服务对接或API调用其实也产生了耦合，并不能简单的迁移到三方的serverless平台去执行。同时，开发者需要引入spring/spring boot/spring cloud相关的依赖，增加了程序的复杂度，又延长了lambda函数clod start需要的时间。另外，开发者需要学习spring cloud function相关的知识，无形中增加了复杂度。总之使用spring cloud function作为函数计算框架收益并不高，整个项目给人感觉比较鸡肋。&lt;/p>
&lt;/blockquote></description></item></channel></rss>