<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on The road</title><link>https://kane.mx/tags/spring/</link><description>Recent content in Spring on The road</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2021, Kane Zhu; all rights reserved.</copyright><lastBuildDate>Fri, 28 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://kane.mx/tags/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Cloud Function -- 跨Serverless平台的函数计算框架</title><link>https://kane.mx/posts/effective-cloud-computing/spring-cloud-function-for-aws/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><guid>https://kane.mx/posts/effective-cloud-computing/spring-cloud-function-for-aws/</guid><description>
&lt;p>&lt;a href="https://kane.mx/posts/2019/serverless-framework/">基于serverless框架的钉钉回调函数&lt;/a>中介绍了serverless framework，一款支持跨云厂商/Serverless平台的部署工具。但是函数代码还是需要针对不同的serverless平台作对应的适配。而&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a>就是针对这种情况专门开发的跨serverless平台的框架，实现一套代码通过不同的打包实现跨serverless平台。Spring Clound Function目前支持AWS Lambda, Microsoft Azure Function以及Apache OpenWhisk。&lt;/p>
&lt;p>这里我们继续使用&lt;a href="https://kane.mx/posts/effective-cloud-computing/serverless-dingtalk-callback/">无函数版本的钉钉回掉函数&lt;/a>来演示&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a> for AWS的使用。&lt;/p>
&lt;p>首先将&lt;code>spring cloud function for aws adapter&lt;/code>添加到项目依赖，&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln">1&lt;/span>&lt;span class="n">implementation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;org.springframework.cloud:spring-cloud-function-adapter-aws:&lt;/span>&lt;span class="si">${springCloudFunctionVersion}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>其次创建函数&lt;code>Handler&lt;/code>，实现Spring Cloud Function跨函数计算实现抽象的&lt;code>SpringBootRequestHandler&lt;/code>类，或者是继承自它的trigger类，例如&lt;code>SpringBootApiGatewayRequestHandler&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln">1&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="nn">org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler&lt;/span>
&lt;span class="ln">2&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Handler&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">SpringBootApiGatewayRequestHandler&lt;/span>&lt;span class="p">()&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>接下来创建Spring Boot应用程序，并将serverless实现函数注册为&lt;code>Spring Bean&lt;/code>，函数的实现部分就是serverless函数具体做的业务逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="ln"> 1&lt;/span>&lt;span class="nd">@SpringBootApplication&lt;/span>
&lt;span class="ln"> 2&lt;/span>&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">DingtalkCallbackApplication&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 3&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nd">@Bean&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="k">open&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">dingtalkCallback&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Function&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">EncryptedEvent&lt;/span>&lt;span class="p">&amp;gt;,&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">callback&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Callback&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Function&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="n">callback&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">handleRequest&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">11&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="ln">12&lt;/span>&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="n">SpringApplication&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">DingtalkCallbackApplication&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ln">14&lt;/span>&lt;span class="p">}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>最后将函数打包为fat jar（如果将依赖打包为lambda layer，可不用打包为fat jar）作为lambda的代码。&lt;/p>
&lt;p>函数的部署同其他的lambda函数没有任何区别，这个示例中沿用了之前的SAM/CloudFormation配置或者&lt;a href="https://serverless.com/">serverless framework&lt;/a>部署配置。&lt;/p>
&lt;p>完整的可运行、部署代码请访问&lt;a href="https://github.com/zxkane/dingtalk-callback-on-aws/tree/spring-cloud-function">这个分支&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>总体来说，&lt;a href="https://spring.io/projects/spring-cloud-function">Spring Clound Function&lt;/a>的实现原理并不复杂，定义统一的函数实现入口，通过不同serverless平台的adapter对接不同平台的API接口，做到编写一次函数实现，通过打包不同的adapter做到跨serverless平台运行。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>但个人认为现实中这样的场景并不多。并且serverless函数触发方式很多，例如AWS上的APIGateway、Kinesis、CloudWatch、IoT等服务，与这些服务对接或API调用其实也产生了耦合，并不能简单的迁移到三方的serverless平台去执行。同时，开发者需要引入spring/spring boot/spring cloud相关的依赖，增加了程序的复杂度，又延长了lambda函数clod start需要的时间。另外，开发者需要学习spring cloud function相关的知识，无形中增加了复杂度。总之使用spring cloud function作为函数计算框架收益并不高，整个项目给人感觉比较鸡肋。&lt;/p>
&lt;/blockquote></description></item><item><title>Spring Cloud or Cloud Native</title><link>https://kane.mx/posts/effective-cloud-computing/spring-cloud-or-cloud-native/</link><pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate><guid>https://kane.mx/posts/effective-cloud-computing/spring-cloud-or-cloud-native/</guid><description>
&lt;p>基于Java的&lt;a href="https://spring.io/projects/spring-cloud">Spring Cloud&lt;/a>是由Java最大开源生态&lt;a href="https://spring.io/">Spring&lt;/a>社区推出的Out-of-Box分布式&lt;a href="https://en.wikipedia.org/wiki/Microservices">微服务&lt;/a>解决方案，&lt;a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Angel-Release-Notes/6e0e1ba3d510d4a30b95c1468007b22f2427fa25">自2016年发布&lt;/a>起就被众多开发者看好。Java作为广为流行的服务端编程语言，&lt;a href="https://spring.io/projects/spring-cloud">Spring Cloud&lt;/a>也就越来越多的被用于微服务开发。&lt;/p>
&lt;p>&lt;a href="https://spring.io/projects/spring-cloud">Spring Cloud&lt;/a>集成了&lt;a href="https://netflix.github.io/">Netflix OSS&lt;/a>开源项目实现了很多功能(或作为实现之一)，包括服务治理、网关路由、客户端负载均衡、服务间调用、断路器等。&lt;a href="https://spring.io/projects/spring-cloud-netflix">Spring Cloud Netflix&lt;/a>将很多生产级别微服务能力开箱即用的带到了Spring Cloud架构下的微服务中，帮助开发者快速的构建满足&lt;a href="https://12factor.net/">12要素&lt;/a>的应用。&lt;/p>
&lt;p>在去年底发布的&lt;a href="https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now#spring-cloud-netflix-projects-entering-maintenance-mode">Spring Cloud Greenwich版本&lt;/a>中宣布&lt;a href="https://spring.io/projects/spring-cloud-netflix">Spring Cloud Netflix&lt;/a>中重要的组件&lt;a href="https://github.com/Netflix/Hystrix#hystrix-status">Hystrix&lt;/a>、&lt;a href="https://github.com/Netflix/ribbon#project-status-on-maintenance">Ribbon&lt;/a>、&lt;code>Zuul 1&lt;/code>等由于上游开源项目进入维护状态，对应的Spring Cloud Netflix项目也进入到维护状态。这些项目将&lt;strong>不再适合&lt;/strong>用于长期维护的产品中！&lt;/p>
&lt;p>同时随着近年云计算的发展，特别是&lt;a href="https://kubernetes.io/">Kubernetes&lt;/a>成为容器编排平台的事实标准，加上&lt;a href="https://www.nginx.com/blog/what-is-a-service-mesh/">Service Mesh(服务网格)&lt;/a>对微服务的服务治理和流量控制，为&lt;a href="https://www.redhat.com/en/topics/cloud-native-apps">云原生应用&lt;/a>提供了更为现代、平台无关的解决方案。&lt;/p>
&lt;p>让我们逐一看看在&lt;a href="https://kubernetes.io/">Kubernetes&lt;/a>加上Serivce Mesh(例如&lt;a href="https://istio.io/">Istio&lt;/a>)如何实现微服务的服务发现、路由、链路追踪、断路器等功能。&lt;/p>
&lt;h3 id="配置中心">配置中心&lt;/h3>
&lt;p>&lt;a href="https://spring.io/projects/spring-cloud-config">Spring Cloud Config&lt;/a>默认提供了多种配置管理后端，例如&lt;code>Git&lt;/code>、&lt;code>Vault&lt;/code>、&lt;code>JDBC Backend&lt;/code>等。同时也有很多开源方案可以作为替换方案，比如&lt;a href="https://github.com/alibaba/nacos">Alibaba Nacos&lt;/a>。&lt;/p>
&lt;p>作为部署在&lt;a href="https://kubernetes.io/">Kubernetes&lt;/a>中的应用，最佳实践是平衡&lt;a href="https://kubernetes.io/docs/user-guide/configmap/">Configmap&lt;/a>和&lt;a href="https://spring.io/projects/spring-cloud-config">Spring Cloud Config&lt;/a>。将涉及程序功能的配置放置在&lt;a href="https://kubernetes.io/docs/user-guide/configmap/">Configmap&lt;/a>和Secret，随同微服务的发布一起做版本管理，可以做到&lt;strong>随着应用回退的时候同时回退到历史对应的配置版本&lt;/strong>，而不会因为历史版本的代码被最新版本的配置所中断。&lt;a href="https://github.com/spring-cloud/spring-cloud-kubernetes">Spring Cloud Kuberentes&lt;/a>项目很好的支持了Spring Cloud应用从&lt;a href="https://github.com/spring-cloud/spring-cloud-kubernetes#kubernetes-propertysource-implementations">Configmap&lt;/a>和&lt;a href="https://github.com/spring-cloud/spring-cloud-kubernetes#secrets-propertysource">Secret&lt;/a>中读取配置项。而涉及业务的配置选项，将可以考虑放到Spring Cloud Config后端实现统一管理。如果应用是部署在阿里云，使用阿里云托管的配置服务和&lt;a href="https://github.com/alibaba/nacos">Spring Cloud Config -- Nacos&lt;/a>将是很好的选择。&lt;/p>
&lt;h3 id="服务发现">服务发现&lt;/h3>
&lt;p>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services">Kubernetes Services&lt;/a>提供了集群内原生的服务发现能力，是&lt;a href="https://spring.io/projects/spring-cloud-netflix">Eureka&lt;/a>或&lt;a href="https://spring.io/projects/spring-cloud-zookeeper">Spring Cloud Zookeeper&lt;/a>等服务发现服务的很好替代品。基于K8S Services的服务发现，很容易通过Service Mesh能力实现限流、A/B测试、金丝雀发布、断路器、chaos注入等服务治理能力。同时对微服务应用来说，不用在应用端添加对应三方库来实现服务注册及发现，减少了应用端开发需求。&lt;/p>
&lt;h3 id="各种流量治理场景">各种流量治理场景&lt;/h3>
&lt;p>应用被服务化后，一定会面临流量治理的问题。对于各种服务间如何实现限流、A/B测试、金丝雀发布、断路器、chaos注入测试、链接追踪等，这其实是一类通用的问题。&lt;/p>
&lt;p>&lt;a href="https://spring.io/projects/spring-cloud">Spring Cloud&lt;/a>提供的是一种客户端解决思路，需要每个应用引入对应功能的libraries的支持。即使通过&lt;a href="https://www.baeldung.com/spring-boot-starters">spring boot starter&lt;/a>提供了近似开箱即用的能力，但是每个应用仍然需要自行添加对应的能力，版本更新、安全漏洞fix等场景都需要手动升级、测试、打包、部署。在异构编程语言实现的微服务架构下，未必每种编程框架都能提供很好的对应能力支持。除非有特别的服务治理策略，不推荐在微服务自身来实现服务流量的控制。&lt;/p>
&lt;p>Service Mesh(例如&lt;a href="https://istio.io/">Istio&lt;/a>或&lt;a href="https://linkerd.io/">Linkerd&lt;/a>)从整个服务治理层面对上述需求提供了统一的解决方案，而不需要微服务做自身的升级或改动。在基于Kuberentes部署运行的微服务应用，Service Mesh提供了统一的服务治理方案，将用户从不同的微服务中自身维护服务治理功能中解放出来，从平台层面提供更加统一一致的解决方案。&lt;/p>
&lt;p>在去年的SpringOne Platform 2018上也有一个Topic &lt;a href="https://youtu.be/AMJQO9zs2eo">A Tale of Two Frameworks: Spring Cloud and Istio&lt;/a> 探讨什么场景应该使用Service Mesh，什么时候使用Spring Cloud服务治理组件，有兴趣的朋友可以看一看。&lt;/p>
&lt;div class="youtube container">
&lt;iframe class="youtube" type="text/html"
src="https://www.youtube.com/embed/AMJQO9zs2eo"
allowfullscreen frameborder="0">
&lt;/iframe>
&lt;/div></description></item></channel></rss>