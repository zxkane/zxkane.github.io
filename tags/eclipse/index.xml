<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Eclipse on The road</title><link>https://kane.mx/tags/eclipse/</link><description>Recent content in Eclipse on The road</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2021, Kane Zhu; all rights reserved.</copyright><lastBuildDate>Sat, 28 Jul 2012 20:49:00 +0800</lastBuildDate><atom:link href="https://kane.mx/tags/eclipse/index.xml" rel="self" type="application/rss+xml"/><item><title>The workaround of making Zend CE/Zend debugger work on mountain lion</title><link>https://kane.mx/posts/archive/blogspot/workaround-of-making-zend-ce-mountain-lion/</link><pubDate>Sat, 28 Jul 2012 20:49:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/workaround-of-making-zend-ce-mountain-lion/</guid><description>
&lt;p>I installed both Zend CE and zend debugger of Eclipse on my Mac. Both of them work well in Mac lion.  However they don't work any more after I upgraded my Mac to mountain lion. &lt;/p>
&lt;p>After some investigation I found some extensions of Zend PHP can't be loaded due to shared library dependency can't be found in mountain lion. The &lt;strong>xslt&lt;/strong> module of PHP depends on some system libraries(suc as /usr/local/libxslt-1.1.23/lib/libxslt.1.dylib) that have been removed by mountain lion.&lt;/p>
&lt;p>The temporary solution is disabling &lt;strong>xlst module&lt;/strong> of zend PHP if your application doesn't need them. &lt;/p>
&lt;p>The workaround fix of Zend CE on Mac, &lt;/p>
&lt;blockquote>
&lt;p>rename &lt;em>&lt;strong>/usr/local/zend/lib/php_extensions/xsl.so&lt;/strong>&lt;/em> to any other name&lt;/p>
&lt;/blockquote>
&lt;p>The workaround fix of zend debugger for Eclipse, &lt;/p>
&lt;blockquote>
&lt;p>Delete the line &lt;em>extension=xsl.so&lt;/em> from file &lt;strong>&lt;your eclipse>/plugins/org.zend.php.debug.debugger.macosx_5.3.18.v20110322/resources/php53/php.ini&lt;/strong>&lt;/p>
&lt;/blockquote></description></item><item><title>The tips of Maven/Tycho building crossplatform RCP and repository</title><link>https://kane.mx/posts/archive/blogspot/tips-of-maventycho-building/</link><pubDate>Tue, 08 Nov 2011 16:16:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/tips-of-maventycho-building/</guid><description>
&lt;p>I successfully converted our product build from PDE build to Maven/Tycho. Something is worth to be documented here.&lt;/p>
&lt;p>There are several examples and posts to demonstrate how using Tycho building your Eclipse plug-ins, features, applications and products. The most helpful example is the &lt;a href="http://git.eclipse.org/c/tycho/org.eclipse.tycho.git/tree/tycho-demo">demo&lt;/a> of Tycho project.&lt;/p>
&lt;p>Below are some traps I met when building my project by Tycho,&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>product build&lt;/strong>&lt;br>
Our product is based on plug-ins, however we added the '&lt;strong>featurelist&lt;/strong>' in build.properties of PDE build to include some root binary for the product. However Tycho doesn't support this type of build, we create some features as the placeholder of plug-ins. Then change the product as features based. You have to manually remove the &lt;strong>plugins&lt;/strong> tag in .product definition file, otherwise Tycho will fail on strange error if the .produce has both &lt;strong>features&lt;/strong> and &lt;strong>plugins&lt;/strong> tag. Then configure the director plugin as not installing features.&lt;/p>
&lt;p>org.eclipse.tycho&lt;br>
tycho-p2-director-plugin&lt;br>
${tycho-version}&lt;br>
materialize-products&lt;br>
materialize-products&lt;br>
false&lt;br>
myappprofile&lt;br>
archive-products&lt;br>
archive-products&lt;/p>
&lt;p>And I used below way to customize the qualifier string of our build.&lt;/p>
&lt;pre>&lt;code>org.eclipse.tycho
tycho-packaging-plugin
${tycho-version}
'${qualifier-prefix}_'yyyyMMddHHmm
&lt;/code>&lt;/pre>
&lt;p>An limitation of director plugin is that no way using different profile name for the application installed on different hosts. I contributed a patch on &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=362550">bug 362550&lt;/a> for this enhancement.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>feature build&lt;/strong>&lt;br>
We have some features to pack some binary files as root files. But Tycho doesn't support root folder that is recognized by PDE build. The workaround is creating an additional folder, then put the root files into it.&lt;br>
Meanwhile Tycho doesn't support wildcard to other native touch points, such as changing the files permission. For static file list use comma separated list as workaround.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>eclipse test plug-in&lt;/strong>&lt;br>
I have a plug-in whose scope is 'test', but it doesn't have test case and no dependency for any test framework, such as junit 3.8 or junit 4. And it's used for mocking test server. Configure surefire plugin to let it build as test plug-in as well.&lt;/p>
&lt;p>org.eclipse.tycho&lt;br>
tycho-surefire-plugin&lt;br>
${tycho-version}&lt;br>
junit&lt;br>
junit&lt;br>
4.1&lt;/p>
&lt;pre>&lt;code> false
&lt;/code>&lt;/pre>
&lt;p>junit&lt;br>
junit&lt;br>
4.1&lt;/p>
&lt;p>And configure the surefire plugin like below to test code in Maven build.&lt;/p>
&lt;p>org.eclipse.tycho&lt;br>
tycho-surefire-plugin&lt;br>
${tycho-version}&lt;br>
my.group&lt;br>
my.feature&lt;br>
${version}&lt;br>
eclipse-feature&lt;br>
my.group&lt;br>
my.testserver&lt;br>
1.0.0&lt;br>
eclipse-plugin&lt;br>
${testSuiteName}&lt;br>
${testClassName} &lt;br>
-Dcom.sun.management.jmxremote&lt;br>
-consoleLog&lt;br>
org.eclipse.equinox.ds&lt;br>
1&lt;br>
true&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>sign jars&lt;/strong>&lt;br>
Add below signjar plugin into parent pom.xml, however I met the md5 error when materializing the repository built on .product. There is a workaround mentioned on &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=344691#c11">Bug 344691&lt;/a>.&lt;/p>
&lt;pre>&lt;code> org.apache.maven.plugins
maven-jarsigner-plugin
1.2
${keystore}
MyCompany
${storepass}
${keypass}
true
${skip.jar.signing}
-tsa
https://timestamp.geotrust.com/tsa
**/artifacts.jar
**/content.jar
jar
eclipse-plugin
eclipse-feature
eclipse-test-plugin
sign
sign
verify
verify&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol></description></item><item><title>Customize PDE build</title><link>https://kane.mx/posts/archive/blogspot/customize-pde-build/</link><pubDate>Fri, 22 Jul 2011 13:59:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/customize-pde-build/</guid><description>
&lt;p>&lt;a href="http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.pde.doc.user/tasks/pde_customization.htm">The documentation of PDE&lt;/a> has a chapter for this topic. Basically it's simply. Copy the template scripts what you want from &lt;em>templates/headless-build&lt;/em> folder under &lt;em>org.eclipse.pde.build&lt;/em> plug-in to your build configuration directory that is the folder has &lt;em>build.properties&lt;/em> file.&lt;/p>
&lt;p>However I found the variables listed in template '&lt;em>customAssembly.xml&lt;/em>' can't be used in the runtime. I filed bug &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=346370">346370&lt;/a> against it.&lt;/p></description></item><item><title>Eclipse P2's import/export capability</title><link>https://kane.mx/posts/archive/blogspot/eclipse-p2s-importexport-capability/</link><pubDate>Fri, 22 Apr 2011 15:56:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/eclipse-p2s-importexport-capability/</guid><description>
&lt;p>I implemented the &lt;a href="https://kane.mx/posts/archive/blogspot/p2-replication-plug-in/">replication tool&lt;/a> at the end of 2009, then published it to &lt;a href="https://kane.mx/posts/archive/blogspot/p2-replication-tool-lives-on-eclipse/">Eclipse Marketplace&lt;/a> in May 2010. However it's not pervasively used due to users have to install that plug-in firstly.&lt;/p>
&lt;p>I searched a similar &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=282419">request&lt;/a> on bugzilla, then I initialized my contribution in the early of this year. Finally it was accepted and will release as part of eclipse itself since Eclipse 3.7 M7! I hope it would benefit the users of Eclipse more and more.&lt;/p>
&lt;p>And I was nominated and elected as the committer of Equinox p2, it's a great honor for me. :)&lt;/p></description></item><item><title>Inside P2's profile (2) - the fragment matches all osgi bundles</title><link>https://kane.mx/posts/archive/blogspot/inside-p2s-profile-2-fragment-matches/</link><pubDate>Tue, 28 Dec 2010 11:33:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/inside-p2s-profile-2-fragment-matches/</guid><description>
&lt;p>Recently our installer met a strange bug, it didn't uninstall all legacy bundles after updating to new version. Finally I found it's due to a magic fragment is missing in the profile due to some causes.&lt;/p>
&lt;p>    &lt;unit id='tooling.osgi.bundle.default' version='1.0.0' singleton='false'>&lt;br>
      &lt;hostRequirements size='1'>&lt;br>
        &lt;required namespace='org.eclipse.equinox.p2.eclipse.type' name='bundle' range='0.0.0' multiple='true' greedy='false'/>&lt;br>
      &lt;/hostRequirements>&lt;br>
      &lt;properties size='1'>&lt;br>
        &lt;property name='org.eclipse.equinox.p2.type.fragment' value='true'/>&lt;br>
      &lt;/properties>&lt;br>
      &lt;provides size='2'>&lt;br>
        &lt;provided namespace='org.eclipse.equinox.p2.iu' name='tooling.osgi.bundle.default' version='1.0.0'/>&lt;br>
        &lt;provided namespace='org.eclipse.equinox.p2.flavor' name='tooling' version='1.0.0'/>&lt;br>
      &lt;/provides>&lt;br>
      &lt;requires size='1'>&lt;br>
        &lt;required namespace='org.eclipse.equinox.p2.eclipse.type' name='bundle' range='0.0.0' multiple='true' greedy='false'/>&lt;br>
      &lt;/requires>&lt;br>
      &lt;touchpoint id='null' version='0.0.0'/>&lt;br>
      &lt;touchpointData size='1'>&lt;br>
        &lt;instructions size='4'>&lt;br>
          &lt;instruction key='install'>&lt;br>
            installBundle(bundle:${artifact})&lt;br>
          &lt;/instruction>&lt;br>
          &lt;instruction key='uninstall'>&lt;br>
            uninstallBundle(bundle:${artifact})&lt;br>
          &lt;/instruction>&lt;br>
          &lt;instruction key='unconfigure'>&lt;/p>
&lt;p>          &lt;/instruction>&lt;br>
          &lt;instruction key='configure'>&lt;br>
            setStartLevel(startLevel:4);&lt;br>
          &lt;/instruction>&lt;br>
        &lt;/instructions>&lt;br>
      &lt;/touchpointData>&lt;br>
    &lt;/unit>&lt;/p>
&lt;p>It has 'hostRequirements' element that represents it's a fragment IU and match all the eclipse's plug-ins in that profile. And this fragment defines the touch point actions for its hosts that will do installBundle action during 'install' phrase and uninstallBundle action during 'uninstall' phrase. It's a very good way to remove the duplicate touch point definitions for all eclipse's plug-ins in the profile.&lt;/p>
&lt;p>BTW, p2's engine also doesn't attach this fragment to the eclipse's plug-in IU if the top level IU doesn't have the STRICT rule. I'm not sure the root cause of designing for it, but it's the fact.&lt;/p></description></item><item><title>Inside P2's profile (1) - inclusion rules</title><link>https://kane.mx/posts/archive/blogspot/inside-p2s-profile-1-inclusion-rules/</link><pubDate>Tue, 28 Dec 2010 11:13:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/inside-p2s-profile-1-inclusion-rules/</guid><description>
&lt;p>You would see some interesting properties at the bottom of eclipse's profile.&lt;/p>
&lt;p>For example,&lt;/p>
&lt;iuProperties id='org.eclipse.sdk.ide' version='3.6.1.M20100909-0800'>
      &lt;properties size='2'>
        &lt;property name='org.eclipse.equinox.p2.internal.inclusion.rules' value='STRICT'/>
      &lt;/properties>
&lt;/iuProperties>
&lt;p>It attaches a property named 'org.eclipse.equinox.p2.internal.inclusion.rules' with value 'STRICT' on the IU 'org.eclipse.sdk.ide' with version 3.6.1.M20100909-0800.&lt;br>
 &lt;br>
It's a very important property for the p2 engine. It means the IU 'org.eclipse.sdk.ide' has been explicitly installed into the profile, so it's not allowed be implicitly updated or removed.&lt;/p>
&lt;p>For example,&lt;br>
We have top feature IU 'org.eclipse.sdk.ide' that represents the Eclipse SDK,   'org.eclipse.pde.feature' that represents the Plug-in Development Tool and 'org.eclipse.jdt.feature' that represents the Java Development Tool. And both JDT and PDT are part of Eclipse SDK, so 'org.eclipse.pde.feature' and 'org.eclipse.jdt.feature' are required by 'org.eclipse.sdk.ide'.&lt;/p>
&lt;p>If the profile only has the STRICT rule for 'org.eclipse.sdk.ide', 'org.eclipse.jdt.feature' and 'org.eclipse.pdt.feature' will implicitly be updated to 3.6.2 when updating 'org.eclipse.sdk.ide' from 3.6.1 to 3.6.2.&lt;/p>
&lt;p>However the profile has below STRICT rule for PDT feature,&lt;/p>
&lt;iuProperties id='org.eclipse.pdt.feature' version='3.6.1.M20100909-0800'>
      &lt;properties size='2'>
        &lt;property name='org.eclipse.equinox.p2.internal.inclusion.rules' value='STRICT'/>
      &lt;/properties>
&lt;/iuProperties>
&lt;p>The p2 engine will report errors due to 'org.eclipse.pdt.feature' has STRICT rule for updating. Hence third-party must explicitly update both 'org.eclipse.sdk.ide' and 'org.eclipse.pdt.feature' from 3.6.1 to 3.6.2.&lt;/p></description></item><item><title>[Eclipse][P2]P2 replication plug-in</title><link>https://kane.mx/posts/archive/blogspot/p2-replication-plug-in/</link><pubDate>Fri, 25 Dec 2009 16:43:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/p2-replication-plug-in/</guid><description>
&lt;p>I wrote a plug-in to simplify the process to install the same plug-ins in different platform or different workstation.&lt;br>
Anyone is interested in it, pls follow below guide to freely use it.&lt;br>
&lt;a href="http://code.google.com/p/kane-toolkit/wiki/P2Replication">http://code.google.com/p/kane-toolkit/wiki/P2Replication&lt;/a>&lt;/p>
&lt;p>Enjoy it.&lt;/p></description></item><item><title>[eclipse]How Equinox load bundles</title><link>https://kane.mx/posts/archive/blogspot/how-equinox-load-bundles/</link><pubDate>Wed, 02 Dec 2009 14:58:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/how-equinox-load-bundles/</guid><description>
&lt;h1 id="how-equinox-load-bundles">How Equinox load bundles&lt;/h1>
&lt;p>Equinox launcher is responsible to start OSGi framework. The system bundle would be created and marked as installed when initializing the framework. Equinox also tries to install the installed bundles if finding them in persistence data during the initializing period. Of course there is no extra bundles would be installed when launching Equinox first time.&lt;br>
&lt;img src="http://docs.google.com/drawings/image?id=sNT8DMKTCXXaH4PoaQOafoA&amp;amp;w=400&amp;amp;h=400&amp;amp;rev=109&amp;amp;ac=1" alt="">&lt;/p>
&lt;p>Then Equinox launcher would install the bundles specified by vm's system property 'osgi.bundles'. And start the initial bundles that are marked as early start. For example, let's have a look at the configuration/config.ini of Eclipse, you would find a line similar as below,&lt;br>
osgi.bundles=reference\:file\:org.eclipse.equinox.simpleconfigurator_1.0.200.v20090831.jar@1\:start&lt;br>
It means the start level of bundle 'org.eclipse.equinox.simpleconfigurator_1.0.200.v20090831.jar' is 1, and it would be started after installing it.&lt;/p>
&lt;p>Here you would ask there are only two bundles are installed(one is system bundle 'org.eclipse.osgi', the other is 'org.eclipse.equinox.simpleconfigurator') when launching Equinox, how the other bundles are installed? It's done by the activate method of 'simpleconfigurator' bundle. The available bundles are recorded in plain text file configuration/org.eclipse.equinox.simpleconfigurator/bundles.info, simpleconfigurator read the file then install those bundles.&lt;/p>
&lt;p>It's a new bundle management introduced by p2. P2 also supports the traditional way to install extensions, such as link file, .eclipseproduct file and directly copying features/plugins.&lt;br>
Below table lists the p2 bundles to implement the compatibility installation feature,&lt;/p>
&lt;p>Bundle&lt;/p>
&lt;p>Usage&lt;/p>
&lt;p>org.eclipse.equinox.p2.directorywatcher&lt;/p>
&lt;p>the definition and implementation of directory watcher API&lt;/p>
&lt;p>org.eclipse.equinox.p2.updatesite&lt;/p>
&lt;p>the implementation of updatesite repository&lt;/p>
&lt;p>org.eclipse.equinox.p2.extensionlocation&lt;/p>
&lt;p>the implementation of extension repository&lt;/p>
&lt;p>org.eclipse.equinox.p2.reconciler.dropins&lt;/p>
&lt;p>scan dropin folder and link files; watch the traditional configuration file used by update manager&lt;/p>
&lt;p>P2 reconciler would scan the dropin, link folder and legacy configuration file in every Equinox launching. You can disable the capability by marking it not be early start.&lt;br>
org.eclipse.equinox.p2.reconciler.dropins,1.0.100.v20091010,plugins/org.eclipse.equinox.p2.reconciler.dropins_1.0.100.v20091010.jar,4,false&lt;/p>
&lt;p>If finding some new bundles in dorpin folder, the reconciler would add the new bundles into a local metadata repository that is stored as OSGi data of Equinox. Then synchronize the bundles into the current p2 profile, then add the new bundles into bundles.info file.&lt;/p></description></item><item><title>[Eclipse][P2]Learn p2 step by step</title><link>https://kane.mx/posts/archive/blogspot/learn-p2-step-by-step/</link><pubDate>Thu, 12 Nov 2009 17:48:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/learn-p2-step-by-step/</guid><description>
&lt;h1 id="learn-p2-step-by-step">Learn p2 step by step&lt;/h1>
&lt;p>&lt;a href="mailto:kane.mx@gmail.com" title="Kane">Kane&lt;/a>               &lt;/p>
&lt;p>                     &lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#Learn_P2_step_by_step">Learn P2 step by step&lt;/a>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#p2_concept">p2 concept&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#p2_install">p2 install&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#p2_install_practice">p2 install practice&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#p2_repository_publish">p2 repository publish&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#customized_p2_touchpoint">customized p2 touchpoint&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#p2_repository_publish_practice">p2 repository publish practice&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#Example_Code">Example Code&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.blogger.com/post-edit.g?blogID=8314384370778429245&amp;amp;postID=6549693887265291061#Reference">Reference&lt;/a>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="p2-concept">p2 concept&lt;/h3>
&lt;p>首先来理解p2引入的几个概念[1]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>p2 / Agent&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provisioning infrastructure on client machines&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Installable Unit (IU)&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Metadata&lt;/strong> that describes things that can be installed/configured&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Artifact&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The actual content being installed/configured(e.g., bundle JARs)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Repository&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A store of metadata or artifacts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Profile&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The target of install/management operations&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Planner&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The decision-making entity in the provisioning system&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Engine&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The mechanism for executing provisioning requests&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Touchpoint&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The part of the engine responsible for integrating the provisioning&lt;br>
system to a particular runtime or management system&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>IU比较好理解，就是对可安装或配置的部分一种描述，并不对应实际要安装的文件。&lt;br>
Arifact就是来描述实际要安装的文件，bundle类型的jar，feature，binary文件。&lt;br>
这时就有了Repository（仓库）这个概念，是用来保存artifacts信息，以及artifacts的元数据。元数据包括了对artifact的唯一标识符，版本，对外暴露的接口信息，以及它依赖的接口及其版本信息，各个安装阶段需要执行的配置。在p2默认的实现里面，这两个repository用xml文件来描述，同时被压缩为artifacts.jar, content.jar来减小文件大小，缩短传输时间。&lt;br>
从Eclipse 3.4起，当从远程site安装新的软件时，就会看到有个work thread在后台下载content.jar文件。p2在安装时候，首先会根据content.xml（metadata repository）来解析正在安装软件的依赖。在当前runtime里面查找metadata中指定的依赖，如果满足才继续安装。据我个人经验，如果安装的软件比较复杂，那它产生的metadata文件就会比较大（很容易上兆），下载这个文件以及解析它的内容都会比较慢，从而影响用户体验。&lt;br>
比较灵活的是，用户可以实现自己的ArtifactRepository和MetadataRepository，注册到它们各自的Manager里面就可以了。所有这些服务都被实现为OSGi Service.&lt;br>
下一个Profile，是用来管理安装目标里的软件信息。p2在被设计的时候，希望解决多个eclipse实例共享一份安装的某软件。比如为了某种目的我机器上有好几个Eclipse，同时它们都需要CDT，免去为重复安装的麻烦。profile就会记录每次安装的内容，让整个应用程序被管理起来。在Galileo里安装的软件都可以软件管理里面查找到。&lt;br>
Planner和Engine完全就是p2内部的东西。任何p2的操作（安装，删除，配置）都需要Planner实例来描述。有了Planner以后，还需要创建一个Engine对象，通过engine来执行对应的plan。这就是目前调用p2 API来完成安装的一个过程。&lt;br>
最后一个Touchpoint。程序在安装的时候，可能会根据runtime(os, ws, arch等）或阶段(安装，卸载，配置等)执行某些配置，touchpoint就是帮助实现这些配置。具体操作是以IU为单位记录在metadata repository里的。p2默认实现了一些Eclipse touchpoint，比如拷贝，删除文件，执行外部程序等。如果用户有自己特殊的native操作需要执行，可以自己实现自定义的touchpoint。&lt;/p>
&lt;h3 id="p2-install">p2 install&lt;/h3>
&lt;p>有了这些概念以后，我们来看看如何使用p2 API。以安装为例，&lt;/p>
&lt;p>首先需要得到当前安装的profile。如果是全新安装，通过IProfileRegistry.addProfile创建一个新profile。是更新安装的话，可以通过IProfileRegistry查询到期望更新的profile。创建profile的时候，需要注意设置profile的属性，&lt;/p>
&lt;p>Map&amp;lt;String, String&amp;gt; profileProperties = new HashMap&amp;lt;String, String&amp;gt;();&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_INSTALL_FOLDER, installLocation.getAbsolutePath());&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_FLAVOR, &amp;quot;tooling&amp;quot;); //$NON-NLS-1$&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_ENVIRONMENTS, &amp;quot;osgi.os=&amp;quot; + Platform.getOS() + &amp;quot;,osgi.ws=&amp;quot; + Platform.getWS() + &amp;quot;,osgi.arch=&amp;quot; + Platform.getOSArch()); //$NON-NLS-1$;&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_NL, &amp;quot;en_US&amp;quot;); //$NON-NLS-1$&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_INSTALL_FEATURES, &amp;quot;true&amp;quot;);&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_CONFIGURATION_FOLDER, new File(installLocation, &amp;quot;configuration&amp;quot;).getAbsolutePath());&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_ROAMING, &amp;quot;true&amp;quot;);&lt;/p>
&lt;p>profileProperties.put(IProfile.PROP_CACHE, installLocation.getAbsolutePath());&lt;/p>
&lt;p>currentProfile = registry.addProfile(PROFILE_ID, profileProperties);&lt;/p>
&lt;p>PROP_INSTALL_FOLDER设置安装的目录，PROP_CACHE设置保存下载来的Eclipse IU(features/plugins)的目录，如果repository是以feature为单位来发布的话，需要设置PROP_INSTALL_FEATURES为true。如果repository包括native的binary（比如launcher）也需要指定正确的PROP_ENVIROMENTS，包括OS,WS,ARCH或PROCESSOR。&lt;/p>
&lt;p>然后需要获得将要安装的IMetadataRepository集合。比如：&lt;/p>
&lt;p>ArrayList&lt;IInstallableUnit> ius = new ArrayList&lt;IInstallableUnit>();&lt;/p>
&lt;p>IMetadataRepositoryManager repositoryManager = (IMetadataRepositoryManager) ServiceHelper.getService(Activator.getDefault().getBundle().getBundleContext(),&lt;/p>
&lt;p>IMetadataRepositoryManager.class.getName()); &lt;/p>
&lt;p>if (repositoryManager == null) &lt;/p>
&lt;p>       throw new InterruptedException(&amp;quot;Failed to get IMetadataRepositoryManager.&amp;quot;);&lt;/p>
&lt;p>try {&lt;/p>
&lt;p>  for (URI uri : uris) {&lt;/p>
&lt;p>    IMetadataRepository metaRepo = repositoryManager.loadRepository(uri, progress.newChild(50/uris.length));&lt;/p>
&lt;p>    Collector collector = metaRepo.query(new AccpetQuery(), new LatestNoninstalledIUCollector(currentProfile), progress.newChild(50/uris.length));&lt;/p>
&lt;p>     ius.addAll(collector.toCollection());&lt;/p>
&lt;p>  }&lt;/p>
&lt;p>} catch (ProvisionException e) {&lt;/p>
&lt;p>    throw new InterruptedException(&amp;quot;Failed to get IMetadataRepository.&amp;quot;);&lt;/p>
&lt;p>}&lt;br>
     -同时这里也查找出IMetaRepository中没安装过的IUs。这就需要同当前安装的profile中已经安装过的内容来比较，&lt;/p>
&lt;p>    Collector collector = metaRepo.query(new AccpetQuery(), new LatestNoninstalledIUCollector(currentProfile), progress.newChild(50/uris.length));&lt;/p>
&lt;p>     这里需要指出的是，IMetadataRepository实现了IQueryable接口。IQueryable是p2引入的查找接口，返回满足特殊查询条件的集合，同时传入了一个IProgressMonitor对象，可以反应查找进度。这里的AcceptQuery，LatestNoninstalledIUCollector是自定义的Query和Collector对象。p2已经实现了许多有用的Query，经常用到的有InstallableUnitQuery，IUPropertyQuery，RangeQuery。&lt;/p>
&lt;p>    -接下来生成IEngine所需的ProvisionPlan。首先创建ProfileChangeRequest对象，将先前查找出的要安装的IUs添加进去。&lt;/p>
&lt;p>     request.addInstallableUnits(ius);&lt;/p>
&lt;p>     删除的话则与之相反。更新的话也需要通过ProfileChangeRequest.removeInstallableUnits()去掉旧版本的IUs。&lt;/p>
&lt;p>     调用IPlanner service的getProvisioningPlan(ProfileChangeRequest, ProvisioningContext, IProgressMonitor)得到对应于当前request的plan。&lt;/p>
&lt;p>    -最后就是调用IEngine.perform(IProfile, PhaseSet, Operand[], ProvisioningContext, IProgressMonitor)来执行provisioning操作。这里的PhaseSet是用来指定Engine将要执行的几个阶段，以及每个阶段的执行时间权重。这些阶段包括了Collect, Unconfigure, Uninstall, Property, CheckTrust, Install, Configure. 如果熟悉Eclipse之前的Installer Handler，对Unconfigure/Uninstall/Install/Configure应该都很熟悉。 在p2里，更是将Collect, CheckTrust这些过程也暴露了出来。下面是p2里默认PhaseSet的实现，&lt;/p>
&lt;p>        public DefaultPhaseSet() {&lt;/p>
&lt;p>            this(new Phase[] {new Collect(100), new Unconfigure(10, forcedUninstall), new Uninstall(50, forcedUninstall), new Property(1), new CheckTrust(10), new Install(50), new Configure(10)});&lt;/p>
&lt;p>        }&lt;/p>
&lt;p>     Operand[]通过ProvisionPlan.getOperands()获得。&lt;/p>
&lt;h3 id="p2-install-practice">p2 install practice&lt;/h3>
&lt;p>先制作一个可安装的repository，这里的方法是基于Eclipse提供的模版创建一个RCP程序，比如mail template,&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_871xs75p2fh_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_871xs75p2fh_b" alt="">&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_872fzbmznfm_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_872fzbmznfm_b" alt="">&lt;/a>&lt;/p>
&lt;p>然后创建一个feature包含刚才创建出来的plug-in 'com.example.mail'。&lt;/p>
&lt;p>基于存在的‘com.example.mail.product’创建product configuration，将其设置为base on features, 同时在dependencies页面添加以下feature。feature的qaulifier id依赖于用到的Eclipsse版本，从下图看到我这里使用的是Eclipse 3.5.1。如果要让RCP程序具有安装插件的能力（包含p2和p2 UI），就需要依赖更多的feature。后面的example里面会实现这部分功能。另外注意：&lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=291872" title="ID不能包括空格字符">ID不能包括空格字符&lt;/a>。&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_873fx44c3ff_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_873fx44c3ff_b" alt="">&lt;/a>&lt;/p>
&lt;p>接下来使用Eclipse Product Export Wizard生成repository。记得要勾选上generate metadata repository。&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_874qnh7n3gc_b">&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_875gfs4p3d2_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_875gfs4p3d2_b" alt="">&lt;/a>&lt;/p>
&lt;p>在成功创建了Mail Application的repository后，试用我们自己的p2 installer来安装这个应用程序。安装过程类似下面的截图。然后执行/folk/kzhu0/tmp/mailrcp/mail来运行Mail Application.&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_877cm6fxcc6_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_877cm6fxcc6_b" alt="">&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_878dg9g8kf4_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_878dg9g8kf4_b" alt="">&lt;/a>&lt;/p>
&lt;h3 id="p2-repository-publish">p2 repository publish&lt;/h3>
&lt;p>这一节将会展示如何发布/产生基于p2的repository。在p2最早的版本Eclipse 3.4中将生成repository这个程序称为generator，而3.5对此重构后命名为publisher。重构后的publish过程简单明了。首先需要创建一个IPublishInfo对象，它负责提供将要生成的repository的情况。包括了meta repository, artifact repository的信息，属性，以及提供辅助信息的advice对象。IPublisherAdvice可以看作类似创建RCP窗口时候的WorkbenchAdvice和WorkbenchWindowAdvice等辅助类。它用来提供需要记录在repository中的IU特殊信息。比如IU的属性，touchpoint的类型及各个阶段执行的action，对可执行文件或配置文件IU的处理。&lt;br>
此外还需要创建IPublisherAction来处理不同类型的IU发布过程。例如BundlesAction来实现发布bundles到repository，FeaturesAction则是处理feature。此外p2已提供的IPublisherAction还包括product action, config action, launcher action和jre action等等[2]。&lt;br>
有了描述repository情况的publishinfo和发布各种IUs的action后，调用Publisher.publish方法完成repository的发布。&lt;br>
        IPublisherInfo info = createPublisherInfo();&lt;br>
        IPublisherAction[] actions = createActions();&lt;br>
        Publisher publisher = new Publisher(info);&lt;br>
        publisher.publish(actions, new NullProgressMonitor());&lt;br>
这里有一点需要注意，publish只是把将要用于部署的features/plugins/binary发布到repository，并不负责编译打包它们。先前我们使用过Eclipse Export功能既编译打包features/plugins同时又生成repository。Export实现的过程首先是调用PDE来编译打包features/plugins，再调用对应的publisher应用程序将编译后的features/plugins/product发布为repository。&lt;/p>
&lt;h3 id="customized-p2-touchpoint">customized p2 touchpoint&lt;/h3>
&lt;p>前面一节已经提过IPublishInfo通过额外的IPublisherAdvise来定制发布到repository的IU信息。这里介绍为自己的IU定制新的touchpoint类型，并且要求在配置阶段在操作系统桌面创建应用程序的启动快捷方式。首先为我们的PublisherInfo添加处理touchpoint data的advice，NativeLauncherTouchPoint实现了ITouchpointAdvice接口，publisher在发布的时候当处理到touchpoint data部分，会查找实现了ITouchpointAdvice接口的advice。如果有advice可用，将会让这些advice处理现有的touchpoint data，并且得到新的touchpoint data，并把结果保存到metadata repository当中。&lt;/p>
&lt;p>        PublisherInfo result = new PublisherInfo();&lt;br>
        result.addAdvice(new NativeLauncherTouchPoint());&lt;/p>
&lt;p>NativeLauncherTouchPoint将指定为特定的IU在configure阶段执行createDesktop操作，以及相反的操作，unconfigure阶段执行deleteDesktop操作。&lt;/p>
&lt;p>更改touchpoint type的方法如下。当然也可以为现有的touchpoint type扩展action。内置的touchpoint类型和action的具体命令用法，请参考p2 wiki[3]。&lt;br>
iu.setTouchpointType(DesktopTouchpoint.TOUCHPOINT_TYPE);&lt;br>
touchpoint类型和action都是通过extension point来扩展的。通过扩展“org.eclipse.equinox.p2.engine.touchpoints”来添加新的touchpoint类型，扩展”org.eclipse.equinox.p2.engine.actions“将新的action同某个类型关联起来。&lt;/p>
&lt;h3 id="p2-repository-publish-practice">p2 repository publish practice&lt;/h3>
&lt;p>我们创建plug-in 'com.example.p2.touchpoint'来实现桌面快捷方式的扩展，并且创建'com.example.p2.feature'包含touchpoint实现的plug-in。具体实现请参考p2 example源码。&lt;br>
然后为Mail Application添加p2相关feature的依赖，重新发布得到支持安装软件的新版本。并且用p2 example installer安装它。p.s: 个人感觉Eclipse在包含第三方plug-in时，层次有些问题。p2作为一个runtime的project（跟equinox, ECF同级），居然需要直接或间接依赖help, rcp.platform这样的上层模块。&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_879cjg6wrgg_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_879cjg6wrgg_b" alt="">&lt;/a>&lt;/p>
&lt;p>接下来创建plug-in 'com.example.mail.desktop' 和 feature 'com.example.mail.desktop.feature'，作为提供桌面快捷方式的IU。用Eclipse Export Feature将'com.example.mail.desktop.feature'导出，实际就是用PDE替我们编译打包:)。&lt;br>
运行‘com.example.p2.generator'提供的headless publisher来生成我们定制的repository。’/folk/kzhu0/tmp/mail/desktop-deploy'是先前desktop feature导出后的路径，而'/folk/kzhu0/tmp/mail/desktop'是生成repository的路径。&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_880tk4fk8wd_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_880tk4fk8wd_b" alt="">&lt;/a>&lt;/p>
&lt;p>运行新版本的Mail Application，在Help菜单下面会多出Install New Software选项。将自定义publisher生成的Desktop feature repository添加为新的软件源，安装Mail Desktop Feature。安装完成后，将在桌面找到Mail Application的快捷方式。在Installation Detail里面将会出现这次安装的内容。选中Desktop Feature后选择卸载，桌面的快捷方式文件将会被删除掉。当然也可以使用p2 example installer来为Mail Application安装desktop feature。p.s: example代码里只实现了创建linux/unix桌面快捷方式。&lt;/p>
&lt;p>&lt;a href="http://docs.google.com/File?id=ddqccrw2_8814qg7wvhs_b">&lt;img src="http://docs.google.com/File?id=ddqccrw2_8814qg7wvhs_b" alt="">&lt;/a>&lt;/p>
&lt;h3 id="example-code">Example Code&lt;/h3>
&lt;p>Example Code应该只能编译运行在Eclipse 3.5.x。Example Code使用的都是p2 internal API, 而p2 public API将会随Eclipse 3.6首次发布。这些类和方法基本都会保留，但命名，包一定会有重构。&lt;br>
&lt;a href="http://code.google.com/p/kane-toolkit/source/browse/#svn/trunk/p2-example">http://code.google.com/p/kane-toolkit/source/browse/#svn/trunk/p2-example&lt;/a>&lt;/p>
&lt;h3 id="reference">Reference&lt;/h3>
&lt;p>[1] &lt;a href="http://wiki.eclipse.org/Equinox/p2/Concepts">http://wiki.eclipse.org/Equinox/p2/Concepts&lt;/a>&lt;br>
[2] &lt;a href="http://wiki.eclipse.org/Equinox/p2/Publisher">http://wiki.eclipse.org/Equinox/p2/Publisher&lt;/a>&lt;br>
[3] &lt;a href="http://wiki.eclipse.org/Equinox/p2/Engine/Touchpoint_Instructions">http://wiki.eclipse.org/Equinox/p2/Engine/Touchpoint_Instructions&lt;/a>&lt;/p></description></item><item><title>Simulate p2 self host in Eclipse run</title><link>https://kane.mx/posts/archive/blogspot/simulate-p2-self-host-in-eclipse-run/</link><pubDate>Tue, 27 Oct 2009 16:12:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/simulate-p2-self-host-in-eclipse-run/</guid><description>
&lt;p>-Dosgi.install.area=&amp;lt;launcher's folder&amp;gt;&lt;br>
-Declipse.p2.profile=&lt;profile id>&lt;/p></description></item><item><title>Eclipse/OSGi preference</title><link>https://kane.mx/posts/archive/blogspot/eclipseosgi-preference/</link><pubDate>Thu, 22 Oct 2009 15:29:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/eclipseosgi-preference/</guid><description>
&lt;p>The IPreferenceStore API of Eclipse is based on OSGi's preferences service. Equinox implements several scope context for different preferences, such DefaultScope, InstanceScope and ConfigurationScope. The IPreferenceStore is the wrapper of instance scope for back-compatibility. It stored the data in workspace(osgi.data.area).&lt;/p>
&lt;p>The workspace folder would be created when launching RCP application if it doesn't exist. But we can use argument '-data @none' to suppress the creation of workspace. If that, the instance scope/IPreferenceStore can't store any value any more.&lt;/p>
&lt;p>There is a workaround to resolve such issue. Use ConfigurationScope instead of InstanceScope. Both of them are implemented the same interface, so it's easy to migrate to use ConfigurationScope. The data of configuration scope would be stored in @config.dir/.setting folder.&lt;/p></description></item><item><title>The usage of Eclipse's Proxy API</title><link>https://kane.mx/posts/archive/blogspot/usage-of-eclipses-proxy-api/</link><pubDate>Wed, 21 Oct 2009 16:53:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/usage-of-eclipses-proxy-api/</guid><description>
&lt;p>Eclipse platform register an OSGi service 'IProxyService' to manage network connection, which has capability to set proxy setting. There are three types of proxy working mode,&lt;/p>
&lt;ul>
&lt;li>Direct(no proxy),&lt;/li>
&lt;li>Manual(specified by user),&lt;/li>
&lt;li>Native(using OS's proxy setting, such as gnome-proxy, IE).&lt;/li>
&lt;/ul>
&lt;p>There are three types of proxy supported by IProxyService. They're http, https and socks.&lt;/p>
&lt;p>It also allows to add/remove ip address from white list, which are accessed without connecting proxy.&lt;/p>
&lt;p>End users can manage the proxy setting of Eclipse via Preference - General - Network Connections. Eclipse would do persistence of user's setting. Other components of Eclipse also use those proxy settings to access network, such as ECF.&lt;/p>
&lt;p>Below code snippet shows how to use proxy API to manually specify proxy server,&lt;/p>
&lt;p>proxyService.setProxiesEnabled(true);&lt;br>
proxyService.setSystemProxiesEnabled(false); &lt;br>
IProxyData[] datas = proxyService.getProxyData(); &lt;br>
IProxyData proxyData = null; &lt;br>
for(IProxyData data : datas) { &lt;br>
// clean old data &lt;br>
((ProxyData)data).setSource(&amp;quot;Manual&amp;quot;); //$NON-NLS-1$ &lt;br>
data.setUserid(null); //$NON-NLS-1$ &lt;br>
data.setPassword(null); //$NON-NLS-1$ &lt;br>
if(proxyType == SOCKSPROXY &amp;amp;&amp;amp; IProxyData.SOCKS_PROXY_TYPE.equals(data.getType())) {&lt;br>
proxyData = data; &lt;br>
continue; &lt;br>
}else if(proxyType == WEBPROXY &amp;amp;&amp;amp; IProxyData.HTTP_PROXY_TYPE.equals(data.getType())){&lt;br>
proxyData = data; &lt;br>
continue; &lt;br>
} &lt;br>
data.setHost(null); //$NON-NLS-1$ &lt;br>
data.setPort(0); &lt;br>
} &lt;br>
if(proxyData != null){ &lt;br>
proxyData.setHost(proxyServer); &lt;br>
proxyData.setPort(proxyPort); &lt;br>
} &lt;br>
try { &lt;br>
proxyService.setProxyData(datas); &lt;br>
} catch (CoreException e) { &lt;br>
proxyService.setProxiesEnabled(false); &lt;br>
proxyService.setSystemProxiesEnabled(false); &lt;br>
return false; &lt;br>
}&lt;/p>
&lt;p>&lt;a href="http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/net/proxy/IProxyService.html">Official API Reference&lt;/a>&lt;/p></description></item><item><title>[OSGi][Eclipse]Add custom jar or path into Equinox Framework</title><link>https://kane.mx/posts/archive/blogspot/add-custom-jar-or-path-into-equinox/</link><pubDate>Sun, 28 Sep 2008 13:23:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/add-custom-jar-or-path-into-equinox/</guid><description>
&lt;p>Set vm arguments 'osgi.framework.extensions' and 'osgi.frameworkClassPath' when vm starts. If those value are set, those jar or path would be added into the classloader when starting EclipseStarter.&lt;/p>
&lt;p>See org.eclipse.equinox.launcher.Main for more details in the source code of Eclipse 3.4.&lt;br>
Best Regards&lt;br>
Kane&lt;/p></description></item><item><title>[OSGi]How to acquire the fragments of specified bundle</title><link>https://kane.mx/posts/archive/blogspot/osgihow-to-acquire-fragments-of/</link><pubDate>Fri, 01 Aug 2008 16:22:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/osgihow-to-acquire-fragments-of/</guid><description>
&lt;p>The answer is very simple, using the service 'org.eclipse.service.PackageAdmin'.&lt;/p></description></item><item><title>[Eclipse]Equinox's classloader and its URL schema</title><link>https://kane.mx/posts/archive/blogspot/eclipseequinoxs-classloader-and-its-url/</link><pubDate>Thu, 17 Jul 2008 17:42:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/eclipseequinoxs-classloader-and-its-url/</guid><description>
&lt;p>Equinox uses the adaptor hooks to implement the class loader.&lt;br>
See &lt;a href="http://wiki.eclipse.org/Adaptor_Hooks">http://wiki.eclipse.org/Adaptor_Hooks&lt;/a> for more detail&lt;/p>
&lt;p>BaseClassLoadingHook would search the native code on itself. If it find the file in that jar file, it would extract the native library into its storage folder.&lt;/p>
&lt;p>EclipseClassLoadingHook defines some variables to search the native library. Belows are built-in variables:&lt;/p>
&lt;p>result.add(&amp;quot;ws/&amp;quot; + info.getWS() + &amp;quot;/&amp;quot;); //$NON-NLS-1$ //$NON-NLS-2$&lt;br>
result.add(&amp;quot;os/&amp;quot; + info.getOS() + &amp;quot;/&amp;quot; + info.getOSArch() + &amp;quot;/&amp;quot;); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$&lt;br>
result.add(&amp;quot;os/&amp;quot; + info.getOS() + &amp;quot;/&amp;quot;); //$NON-NLS-1$ //$NON-NLS-2$&lt;/p>
&lt;p>So the classloader can find your native library that under those path. If your bundle is jar file, equinox would extract your native library into its storage folder.&lt;/p>
&lt;p>I prefer to use OSGi header(Bundle-NativeCode) defining the path of native code, which still works on other OSGi implementations.&lt;/p>
&lt;p>Equinox defines its url schema, one of them is named as 'BundleURLConnection'. From its name, we know it's used for describing the files of bundle. You can obtain the url of file that is located on bundle by Bundle.getResource()/Bundle.getEntry()/Bundle.findEntries()/Bundle.getResources(). The return value of those functions are an object of BundleURLConnection. Once it's used as the argument of FileLocator.toFileURL(URL), the jar bundle would be unpacked into its storage folder recursively.&lt;/p></description></item><item><title>[OSGi][Equinox]the Bundle-NativeCode implementation in Equinox</title><link>https://kane.mx/posts/archive/blogspot/bundle-nativecode-implementation-in/</link><pubDate>Mon, 31 Mar 2008 17:36:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/bundle-nativecode-implementation-in/</guid><description>
&lt;p>OSGi Spec defines Bundle-NativeCode header to contain a specification of native code libraries contained in that bundle. All magic things are initialized by org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLibrary(String) and org.eclipse.osgi.framework.internal.core.BundleLoader.findLibrary(String). Then BundleLoader uses the org.eclipse.osgi.baseadaptor.BaseData(an implementation of BundleData) to find the library path, if the bundle is NOT a jar file, it would directly get the absolute path of library. Otherwise, the BaseData would extract the library file if it could NOT find it in OSGi bundle storage(located in ${data}/org.eclipse.osgi/bundles/[bundle_id]/.cp/). Refer to org.eclipse.osgi.baseadaptor.BaseData.findLibrary(String) for more detail.&lt;/p></description></item><item><title>[Eclipse]How to use qualifier string when exporting features and plug-ins</title><link>https://kane.mx/posts/archive/blogspot/how-to-use-qualifier-string-when/</link><pubDate>Tue, 11 Mar 2008 13:30:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/how-to-use-qualifier-string-when/</guid><description>
&lt;p>You must see the qualifier string property when exporting your features and plug-ins by Eclipse pde. But specified qualifier string won't appear after you export the features successfully.&lt;/p>
&lt;p>If you want to use the qualifier string, you must define your feature and plug-in version like below:&lt;br>
1.0.0.qualifier, 2.2.2.qaulifier&lt;/p>
&lt;p>:)&lt;/p></description></item><item><title>[Eclipse]get rid of the menus of eclipse platform</title><link>https://kane.mx/posts/archive/blogspot/get-rid-of-menus-of-eclipse-platform/</link><pubDate>Fri, 09 Mar 2007 13:46:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/get-rid-of-menus-of-eclipse-platform/</guid><description>
&lt;p>When you develop a rich client application base on eclipse framework, and your application require eclipse platform feature, you would find that your application has some menu items contributed by eclipse platform. Those menu items are defined by several plug-ins' implementation of actionSet extention point. In fact Eclipse provides an activity mechanism to suppress the extension points which you don't want to use. However, you must know the identification name of extension points which you want to suppress. It's a hard work to find out all of them from dozens of plugins. so, I wrote a utility function to list all the extension points of specified name.&lt;/p>
&lt;pre>&lt;code> IExtensionRegistry registry = Platform.getExtensionRegistry();
IExtensionPoint extensionPoint = registry.getExtensionPoint(&amp;quot;org.eclipse.ui.actionSets&amp;quot;);
IExtension\[\] extensions = extensionPoint.getExtensions();
for(int i = 0; i &amp;lt; extensions.length; i++){
IConfigurationElement elements\[\] = extensions\[i \].getConfigurationElements();
for(int j = 0; j &amp;lt; elements.length; j++){
String pluginId = elements\[j\].getNamespaceIdentifier();
if(pluginId.indexOf(&amp;quot;org.eclipse&amp;quot;) &amp;gt; -1){ //$NON-NLS-1$
IConfigurationElement\[\] subElements = elements\[j\].getChildren(&amp;quot;action&amp;quot;);
for(int m = 0; m &amp;lt; subElements.length; m++){
System.out.println(&amp;quot;Plugin: &amp;quot; + pluginId + &amp;quot; Id: &amp;quot; +
subElements\[m\].getAttribute(&amp;quot;id&amp;quot;));
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>and the follow snippet is about the activities of menus of eclipse platform:&lt;/p>
&lt;extension point="org.eclipse.ui.activities">
&lt;activity id="activity.platform" name="hidePlatformMenus"/>
&lt;activityPatternBinding activityId="activity.platform" pattern="org\\.eclipse\\.platform/org\\.eclipse\\.ui\\.cheatsheets\\.actions\\.CheatSheetHelpMenuAction"/>
&lt;activity id="activity.search" name="hideSearchMenus"/>
&lt;activityPatternBinding activityId="activity.search" pattern="org\\.eclipse\\.search/org\\.eclipse\\.search\\..*"/>
&lt;activity
id="activity.ide"
name="hideIDEMenus">
&lt;/activity>
&lt;activityPatternBinding
activityId="activity.ide"
pattern="org\\.eclipse\\.ui\\.ide/org\\.eclipse\\.ui\\.actions\\.showKeyAssistHandler">
&lt;/activityPatternBinding>
&lt;activityPatternBinding
activityId="activity.ide"
pattern="org\\.eclipse\\.ui\\.ide/org\\.eclipse\\.update\\.ui\\..*">
&lt;/activityPatternBinding>
&lt;activity
id="activity.editor"
name="hideEditorMenus">
&lt;/activity>
&lt;activityPatternBinding
activityId="activity.editor"
pattern="org\\.eclipse\\.ui\\.editors/org\\.eclipse\\.ui\\.edit\\.text\\.openExternalFile">
&lt;/activityPatternBinding>
&lt;activityPatternBinding
activityId="activity.editor"
pattern="org\\.eclipse\\.ui\\.editors/org\\.eclipse\\.ui\\.edit\\.text\\.delimiter\\..*">
&lt;/activityPatternBinding>
&lt;activity
id="activity.externaltool"
name="hideExternaltoolMenus">
&lt;/activity>
&lt;activityPatternBinding
activityId="activity.externaltool"
pattern="org\\.eclipse\\.ui\\.externaltools/org\\.eclipse\\.ui\\.externaltools\\.ExternalToolMenuDelegateMenu">
&lt;/activityPatternBinding>
&lt;/extension></description></item><item><title>[Eclipse]Eclipse update support</title><link>https://kane.mx/posts/archive/blogspot/eclipse-update-support/</link><pubDate>Wed, 17 Jan 2007 13:51:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/eclipse-update-support/</guid><description>
&lt;p>Those days my work is focus on eclipse's update. Now I understand the general mechanism and meet some issues when using it in development work.&lt;/p>
&lt;p>The update mechanism includes four major types: install, enable, disable and uninstall. And all of those operations can be executed by command line, such as installing a feature can use following line:&lt;br>
-application org.eclipse.update.core.standaloneUpdate -command install -featureId my.feature -version 1.0.0 -from file:/v:/local_updateSite/ -to file:/v:/eclipse/.&lt;br>
The installation process would copy the feature and plugins which are included by the feature to the local site from the update site, then execute the feature's global install handler if it has one.&lt;/p>
&lt;p>Some strange issue occurs when I want to disable a feature.Then I try to disable the feature with command,&lt;br>
-command disable -featureId my.feature -version 1.0.0 -to file:/v:/eclipse/&lt;br>
The output of command means that the command is executed successfully.&lt;br>
But I list the status of features with command line &amp;quot;-command listFeatures&amp;quot;, the status of my.feature is still enable.&lt;br>
Then I try to uninstall my.feature with command,&lt;br>
-command uninstall -featureId my.feature -version 1.0.0 -to file:/v:/eclipse/&lt;br>
It fails, and the following is the root cause found in log file.&lt;br>
!MESSAGE [Cannot find unconfigured feature my.feature with version 1.0.0]&lt;br>
unconfigured feature means the feature is disabled.&lt;/p>
&lt;p>I posted my question in forum, and one guy told me that it might be a bug of eclipse and advised me to fire a bug for it.&lt;/p></description></item><item><title>[Eclipse]The call sequence between partActivated and menu update</title><link>https://kane.mx/posts/archive/blogspot/call-sequence-between-partactivated-and/</link><pubDate>Thu, 19 Oct 2006 12:42:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/call-sequence-between-partactivated-and/</guid><description>
&lt;p>I met a defect that dynamically created menu items disappear after creating a new viewPart. It caused me overtime last Friday. Today I find the root cause.&lt;/p>
&lt;p>The scenario is:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>open first document, the items are shown well&lt;/p>
&lt;/li>
&lt;li>
&lt;p>open another document, the items disappear&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The requirement is that showing the menu items while current part is document, otherwise hide them.&lt;/p>
&lt;p>So our implementation is:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>when current document part is deactivated, set menu items invisible&lt;/p>
&lt;/li>
&lt;li>
&lt;p>when document part is activated, set menu items visible&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>After debugging, I found that menu items was updated before the part activated listener was notified. Hence the menu is invisible while the parent menu is updated. The resolved solution is that setting menu items visible while part opened listener is notified.&lt;/p></description></item><item><title>[debug][java]Remote debug in Eclipse</title><link>https://kane.mx/posts/archive/blogspot/remote-debug-in-eclipse/</link><pubDate>Wed, 18 Oct 2006 12:53:00 +0800</pubDate><guid>https://kane.mx/posts/archive/blogspot/remote-debug-in-eclipse/</guid><description>
&lt;p>I need use remote debug in our project, however just some experience in Weblogic were found from internet. After my investigation, I got some experience about using Eclipse remote debug RCP.&lt;br>
There are two important parameters for jvm. And we must launch remote java app with those two parameters.&lt;br>
-Xdebug //tells jvm starting with debug mode&lt;br>
-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044 //transport=dt_socket represents communication with socket, address=1044 represents that the port number is 1044&lt;br>
Then there are 3 steps in local env:&lt;br>
1.import source code into eclipse's project&lt;br>
2.Debug-Remote Java Application, see attachement as a sample&lt;br>
3.insert breakpoint,&lt;/p>
&lt;p>update:&lt;br>
a simpler way:&lt;br>
-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000&lt;/p></description></item></channel></rss>